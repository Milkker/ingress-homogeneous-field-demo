<!DOCTYPE html>
<html>
  <head>
  	<meta charset="UTF-8">
  	<title>Ingress homogeneous field demo</title>
  	<link rel='stylesheet' href='style.css' type="text/css">
  	<!-- Latest compiled and minified CSS -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  	<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
  	<!-- Latest compiled and minified JavaScript -->
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
  	<script src='https://cdnjs.cloudflare.com/ajax/libs/vue/2.2.5/vue.min.js' type="text/javascript"></script>
  	<script src="combinations.js"></script>
  </head>
  <body>
  	<div id='app1' class='container-fluid'>
  		<nav class="navbar navbar-default navbar-fixed-top">
  			<div class="container-fluid">
    			<div class="navbar-header">
      				<a class="navbar-brand" href="#">{{level+1}}重三角({{this.getPolygons().length}} CF){{seqno==-1 ? '': ('&nbsp;-&nbsp;第' + seqno +'步')}}</a>
      			</div>
  				<div class="nav navbar-nav navbar-right">
	  				<div class="btn-group" role="group" aria-label="切換多重">
				  		<button class='btn btn-default' @click='decreaseLevel'>
				  			<span class="glyphicon glyphicon-minus" aria-hidden="true"></span>
				  		</button>
				  		<button class='btn btn-default' @click='increaseLevel'>
				  			<span class="glyphicon glyphicon-plus" aria-hidden="true"></span>
				  		</button>
				  	</div>
	  				<div class="btn-group" role="group" aria-label="切換步驟">
				  		<button class='btn btn-default' @click='decreaseSeqno'>
				  			<span class="glyphicon glyphicon-arrow-left" aria-hidden="true"></span>
				  		</button>
				  		<button class='btn btn-default' @click='increaseSeqno'>
				  			<span class="glyphicon glyphicon-arrow-right" aria-hidden="true"></span>
				  		</button>
			  		</div>
	  				<button class='btn btn-default' @click='reset'>
	  					<span class="glyphicon glyphicon-repeat" aria-hidden="true"></span>
	  				</button>
		  		</div>
  				<form id='navbar_form' class="navbar-form navbar-right">
  					<div class="form-group">
  						<label class="form-label" for="color">線條:</label>
				  		<label v-for='color in colors'>
				  			<input type="radio" v-model="pathColor" :value="color"/>
				  			<span :class='color + "-active pathColor"'>■</span>&nbsp;
				  		</label>
  					</div>
  					<div class="form-gorup">
  						<label class="form-label" for="seqno">步驟:</label>
	  					<input class="form-control" type="range" v-model='seqno' min='-1' :max='getMaxSeqno'/>
  					</div>
  				</form>
			</div>
		</nav>
		<svg id='svg1' width="1024" height="768">
		    <polygon v-for="polygon in polygons" :points="polygon | polygon_points" :style="polygon | polygon_style" />
		    <path v-for="path in paths" :d="path | path_d" @mouseover='toogleOver' @mouseout='toogleOver' @click='toogleActive' fill='none' stroke='white' :stroke-width="r" />
		    <circle v-for="circle in filterCircles" :cx="circle.x" :cy="circle.y" :r="r" stroke="none" fill="red"/>
	  	</svg>
  	</div>
  	<script type="text/javascript">
  	  var app = new Vue({
  	  	el:"#app1",
  	  	filters: {
  	  		path_d : function(path){
  	  			return 'M' + path.begin.x + ' ' + path.begin.y + ' L' + path.end.x + ' ' + path.end.y;
  	  		},
			polygon_points: function(polygon){
			   var points = "";

			   for(var idx in polygon)
			     points += polygon[idx].x + "," + polygon[idx].y + " ";

			   return points;
			},
			polygon_style: function(polygon){
			   return 'fill:blue;stroke:none;fill-opacity:0.1'
			}
  	  	},
		data : {
		  colors:['red', 'green', 'blue', 'purple', 'black'],
		  pathColor:'red',
		  seqno: -1,
		  level: 0,
		  circles:[
		    {level:0, x:100, y:742.820323},
			{level:0, x:900, y:742.820323},
			{level:0, x:500, y:50}
		  ],
		  history:[]
		},
		created: function(){
			var circles = JSON.parse(JSON.stringify(this.circles));

			this.history.push(
			{
				level:0,
				paths:[
				  { level:0, beginLevel:0, endLevel:0, begin:circles[0], end:circles[1]},
				  { level:0, beginLevel:0, endLevel:0, begin:circles[1], end:circles[2]},
				  { level:0, beginLevel:0, endLevel:0, begin:circles[2], end:circles[0]}
				],
				polygons:[
					circles
				]
			});
		},
		computed:{
			r:function(){
				return (1/Math.pow(this.level+1, 0.5)) * 3;
			},
			filterCircles: function(){
				var self = this;
				return this.circles.filter(function(el){
					return el.level <= self.level
				});
			},
			paths: function(){
			  var result=[];

			  for(var curLevel = 0; curLevel<=this.level; curLevel++)
			  	for(var idx in this.history[curLevel].paths)
			  	{
			  		var path = this.history[curLevel].paths[idx];
			  		var curSeqno = this.getSeqByPath(this.level, path.beginLevel, path.endLevel)

			  		if(this.seqno <= -1 || this.seqno >= curSeqno)
			  			result.push(path);
			  	}

			  return result;
			},
			polygons: function(){
			  return this.getPolygons();
			},
			getMaxSeqno: function(){
				return this.getMaxSeqno2();
			}
		},
		methods:{
			getMaxSeqno2: function(){
				return (this.level + 2) * (this.level + 1) / 2 - this.level;
			},
			toogleOver:function(){
				event.target.classList.toggle(this.pathColor + '-active');
			},
			toogleActive:function(){
				var el = event.target;
				
				[].forEach.call(this.colors, function(color){
					if(color.vale != this.pathColor)
						el.classList.remove(color.value + '-active');
				});

				el.classList.toggle(this.pathColor + '-active');
			},
			getPolygons:function(){
			  var result=[];

			  for(var curLevel = 0; curLevel<=this.level; curLevel++)
			  	Array.prototype.push.apply(result, this.history[curLevel].polygons);

			  return result;
			},
			reset:function(){
				this.seqno = -1;
				this.level = 0;
			},
			decreaseSeqno: function(){
				if(this.seqno > -1)
					this.seqno--;
			},
			increaseSeqno:function(){
				var max = this.getMaxSeqno2();

				if(max > this.seqno)
					this.seqno++;
			},
			decreaseLevel: function(){
				if(this.level > 0)
					this.level--;
			},
			increaseLevel: function(){
				var self = this;
				var hasHistory = false;
				self.seqno = -1;

				//檢查歷史紀錄
				for(var idx in this.history)
				{
					if(this.history[idx].level == this.level+1){
						this.level++;
						hasHistory = true;
						break;
					}
				}
				if(hasHistory || (this.level >= 5 && !confirm('因連線數限制，最多實現六重三角，確定要突破極限？')))
					return;

				var newLevel = this.level+1;
				var newPoints = [];
				var newPaths = [];
				var newPolygons = [];
				var oldPolygons = this.getPolygons();

				for(var idx in this.history[this.level].polygons){
				  var polygon = this.history[this.level].polygons[idx];
				  var newPoint = this.getTriangleHeart(polygon[0], polygon[1], polygon[2]);

				  if(!this.circles.includes(newPoint)){
				  	newPoint.level = newLevel;
				  	newPoints.push(newPoint);

				  	//get new path
				  	newPaths.push({ level:newLevel, beginLevel:polygon[0].level, endLevel:newPoint.level, begin:polygon[0], end:newPoint});
				  	newPaths.push({ level:newLevel, beginLevel:polygon[1].level, endLevel:newPoint.level, begin:polygon[1], end:newPoint});
				  	newPaths.push({ level:newLevel, beginLevel:polygon[2].level, endLevel:newPoint.level, begin:polygon[2], end:newPoint});

				  	//get new polygon
				    var newPolygonCombs = k_combinations([polygon[0], polygon[1], polygon[2], newPoint], 3).filter(function(newPolygon)
			    	{
			      		//排除已存在的組合
			    		return !self.checkExist(oldPolygons, newPolygon);
			    	});

					Array.prototype.push.apply(newPolygons, newPolygonCombs);
				  }
				}

				this.level = newLevel;

				Array.prototype.push.apply(this.circles, newPoints);
				this.history.push({
				  level: this.level,
				  paths: newPaths,
				  polygons: newPolygons
				});
			},
			polygonGenerator: function(pointsArray){
			   var points = "";

			   for(var idx in pointsArray)
			     points += pointsArray[idx].x + "," + pointsArray[idx].y + " ";

			   return {
			     points: points,
			     style: 'fill:blue;stroke:black;stroke-width:'+1/Math.pow(this.level+1, 0.5)+';fill-opacity:0.3'
			   };
			},
			//取得三角形內心座標
			getTriangleHeart: function(a, b, c){
			  var getLength = function(a, b){
			    return Math.pow(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2), 0.5);
			  };
			  var length_ab = getLength(a,b),
			      length_bc = getLength(b,c),
			      length_ac = getLength(a,c);
			  var totalLenth = length_ab + length_bc + length_ac;
			  
			  return {
			    x: Math.round(((a.x * length_bc + b.x * length_ac + c.x * length_ab)/totalLenth) * 10000) / 10000,
			    y: Math.round(((a.y * length_bc + b.y * length_ac + c.y * length_ab)/totalLenth) * 10000) / 10000,
			  }
			},
			checkExist: function(polygonList, polygon){
				for(var idx in polygonList){
					var exist = false;
					for(var idx2 in polygon){
						if(polygon[idx2].x != polygonList[idx][idx2].x || polygon[idx2].y != polygonList[idx][idx2].y)
							break;
						else if(idx2 == 2)
							exist = true;
					}
					if(exist)
						return true;
				}
				return false;
			},
			getSeqByPath: function(level, beginLevel, endLevel){
				//舊版level base on zero 但計算公式是base on one。
				level++;
				beginLevel++;
				endLevel++;

				var h = level - beginLevel + 1;
				var maxNumInPreviousRow = h * (h - 1)/2;

				return endLevel - beginLevel + maxNumInPreviousRow + 1 - h + (h == level ? 1 : 0);
			},
			getPathBySeq: function(level, seq){
				var h = Math.ceil((Math.pow(8*seq + 1, 0.5) - 1) / 2);
				var maxNumInRow = h * (1 + h)/2;

				//舊版level base on zero 但計算公式是base on one。
				return {
					beginLevel: level - h + 1 - 1,
					endLevel: level + seq - maxNumInRow - 1
				}
			}
		},
  	  });
	  window.addEventListener('keyup', function(event) {
	  	switch(event.keyCode)
	  	{
	        // Left-Arrow
	        case 37:
	          app.decreaseSeqno();
	          break;
	      	// Up-Arrow
	        case 38:
	          app.increaseLevel();
	          break;
	      	// Right-Arrow
	        case 39:
	          app.increaseSeqno();
	          break;
	      	// Down-Arrow
	        case 40:
	          app.decreaseLevel();
	          break;
	  	}
      });
  	</script>
  </body>
</html>